\section{Missions réalisées}
Au cours de mon stage j'ai pu intervenir sur différents projets allant d'un simple script permettant de dynamiser une page web d'un client à la reprise d'un projet complet. Ici nous allons détailler les deux principales missions de mon stage à savoir le développement de widget en vueJS pour le studio Digital et la finalisation des XRM du \textit{Consortium du Jambon de Bayonne} et d'\textit{Interporc Franche-Compté}.

\subsection{Widget pour le studio Digital}
Lors de mon arrivé dans l'entreprise, celle ci cherchait a valorisé ses formation en devenant Organisme de formation certifié \textbf{QUALIOPI}. QUALIOPI est une certification qui garanti des formations avec: 
\begin{itemize}
    \item des bons résultats
    \item des adaptations au besoins
    \item des formateurs qualifiés
    \item une bonne prise en compte des retours face au formations
\end{itemize} 
Afin de correspondre à ces critères, nous avions besoin de construire un site web qui permettrait d'effectuer les questionnaires des différents modules de la formations, ainsi que le formulaire de satisfaction. Puis par la suite de pouvoir consulter les différentes statistiques des différents modules sous 3 vue différentes, formés, qui doit voir uniquement ses résultats, entreprise qui ne voit que les statistiques de ses employés formés, une visions globale qui permettra de voir toutes les statistiques des personnes formées.

La première étape réalisé afin de pouvoir réaliser ceci à était d'adapter l'enregistrement des formulaires du studio qui jusque là ne nous permet pas d'effectuer simplement des statistiques. 

\subsubsection{Serializations des données des formulaires}

Afin de récolter les données des formulaire, le studio digital passe par un serializer qui va enregistrer dans un fichier json les valeurs des différents champs associé à leur id. Ce système présente plusieurs avantage comme la facilité et la rapidité d'implémentation. Maleureusement ceci ne nous permet pas de savoir si une réponse est, dans notre cas, correcte ou non. Ou encore pouvoir associé le label d'une question à son résultat. 

Pour atteindre le résultat souhaité j'ai du implémenter un nouveaux widget pour le studio digital en VueJS. Ce widget est un simple bouton de correction qui va devoir récupérer tout le contenu nécéssaire du formulaire et les stocker dans des champs cachés afin de se servir du serializer. Le reste du formulaire étant coder en JQuery/html, la seule solution était donc de parcourir le formulaire et de récupérer les information dans le DOM afin de réccupérer les informations nécéssaire. A savoir les information permettant le calcule de la note, diverses meta-données par rapport au question comme le label, l'id du champ concerné,le résultat obtenu a la question, etc.. 

Dès que ces informations fut récupérer il ne rester plus qu'a établir les différentes requêtes nécéssaire à la récupération des données en fonction du périmetre défini (formé, entreprise, admin)


\subsubsection{Compréhension de l'API et implémentation des requêtes}

Dans l'actuel implémentation du serveur Send-Up, la partie gérent les \textit{Recordset} - Table MySQL comportant un champ info destiné à stocker du JSON - est gérer par une partie de l'API dont les routes pointant vers cette partie sont générer automatiquement à partire du nom de la méthode défini dans le controlleur.Exemple la méthode postRecordset est appelée lors d'une requête POST sur /Recordset. De plus l'une des complications a été de comprendre le format des données à envoyer dans la requête. En cherchant plus profondément dans le code je me suis rendu compte que seuls les \textbf{FormData} était accepter pour la requête existante.
Une fois le fonctionnment compris il suffisait d'implémenter une requête à la base de donées prenant en compte la portée dans laquel on se trouvé afin de renvoier uniquement les donées nécéssaire.

\subsubsection{Création des widgets}

Une fois les données récupérer et les requêtes créer il fallait que je créer 5 widgets différents qui permeté de: 
\begin{itemize}
    \item visualiser les résultats d'une personnes formée pour chaque tentatives. 
    \item  visualiser les réponses avec correction d'une personne formée.
    \item afficher les statistiques globale de la formations c'est a dire le nombre de bonne réponse par rapport au nombre de personne.
    \item afficher les statisques globale pour le formulaire de satisfaction client. 
    \item afficher les réponses d'une personnes formé au questionnaires de satisfaction.  
\end{itemize}

Après avoir développer certains d'entre eux, il s'avèra que certains traitement se répeter ou se resembler fortement. Or VueJS integre ce qui appèle les \textit{Mixins}, ces éléments possède les mêmes caractéristique dans leur balise script qu'un composant vueJS classique. Mais ce dernier à la possibilité d'être intégré à l'intérieurs de composant (ou autre Mixins). Chaque composant hérite donc des donnés, méthodes et autres propriétés calculé. Ceci empêche donc la redondance et facilite la maintenabilité.
C'est donc pour cela, que j'ai créer un mixins spéciale afin de facilité la lisibilité et la maintenance du code. 


\subsection{Reprise d'un projet XRM}
Suite au départ d'un développeur de l'équipe. On m'a placer sur la reprise de son projet qui consite a creer un XRM permetant tous les points de contrôle concernant le \textit{Consortium du Jambon de Bayonne} et \textit{Interporc Franche-Compté}.
Un XRM est un logiciel de gestion des relations tiers. C'est à dire des clients, fournisseur, revendeur etc... En plus de réaliser ceci le notre doit permettre de pouvoir de créer et de réaliser des audits, en fonction du type d'activité et du cahier des charges de la personne audité, et de pouvoir saisir les données issue d'analyse laboratoire.

Toute la partie audit a était réaliser par mon prédécésseur, il me reste donc à implémenter la parite Analyse et prélévement. 

\subsubsection{Fonctionnalités}
Tout d'abord passons en revus les fonctionalités souhaité par les clients. Ici nous avons 2 client différents avec des besoins différents.
\begin{itemize}
    \item En tant que Consortium, je souhaite pouvoir créer des fiches prélevements. En fonction du cahier des charges, type d'activité de la personne audité il est possible d'avoir plusieurs champs différents définis dans un fichier de configuration.
    \item En tant que Consortium, je souhaite pouvoir ajouter des des analyses à un prélévement. Chaque analyse possède un type dépendant des champs sélectionnés dans la fiche prélévement. Ceci conditionera les champs spécifique de l'analyse
    \item En tant que qu'Interporc, je souhaite pouvoir créer des fiches analyse. Les champs spécifiques dépendent uniquement du type de produit sélectionner: Saucisse, Lisier, Lactoserum, Sel. 
    \item En tant qu'Interporc et Consortium, je souhaite pouvoir lever des écarts à chaques analyses si besoin est.  
    \item En tant qu'Interporc et Consortium, je souhaite pouvoir téléverser les résultats des laboratoires et les associé à une analyse. 
\end{itemize}



\subsubsection{Analyse de l'existant}


Après avoir discuter avec mon chef des projet, et mon maitre de stage, on a determiner qu'un audit et un prélévement se ressembler énormément. En effet chacun et relier à un auditeur/préleveur, une personne audité, un ou plusieurs cahier des charges et un ou plusieurs type d'activités. 

Pour cela les audits sont stocké dans une table nommé \textit{Recordset\_app}.Cette classe possède un champ info au format JSON, comme la classe \textit{Recordset}  décrit précédement. La grande différence est que cette dernière est gérér par une classe abstraite nommé \textit{AbstractSheet}, qui définis que le champs info possède au minimum un un champ builder, data et files. Chaque entité voulant être stocker dans la table Recorset\_app doit étre hérité de cette classe et donc respecter ce schéma. Pour différencier nos sous classe nous faisont appel une fonction de doctrine appelée le discriminant. Il permet d'associé un entier a une classe. A ce jour nous avons 2 classe héritant de AbstracSheet: 
\begin{enumerate}
    \item \textit{Recordset\_app} : qui correspond à toute les fiches standard. 
    \item \textit{SubscriberAudit}: qui correspond au audit créer par nos subscriber. 
\end{enumerate}

Voila pour l\'existant au niveaux de l\'api. Voyons maintenant comment à était construit les audit afin de pouvoir garder une cohérence dans l'application et de pouvoir réutiliser au maximum les composants déjà créer. 

